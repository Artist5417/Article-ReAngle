# 错误处理与日志系统文档

本文档概述了 Article ReAngle 项目中实现的新错误处理和日志架构。该系统使用 `loguru` 进行结构化、上下文感知的日志记录，并使用集中的 FastAPI 异常处理器来提供一致的 API 错误响应。

## 1. 系统概述

-   **统一日志**：使用 `loguru` 替代散落的 `print()` 语句，提供结构化日志（`INFO`, `ERROR`, `DEBUG`）。
-   **集中错误处理**：所有异常都由 `app/core/handlers.py` 中的全局处理器捕获，并转换为标准的 JSON 格式。
-   **请求追踪**：每个请求都会被分配一个唯一的 `request_id`，该 ID 会出现在所有相关的日志条目中。

## 2. 日志架构

### 配置
-   **文件**: `app/configs/logger.py`
-   **库**: `loguru`

### 特性
1.  **拦截**: 标准 Python `logging` 消息（来自 Uvicorn, FastAPI）会被拦截并重定向到 Loguru，确保统一的日志格式。
2.  **请求上下文**:
    -   中间件为每个请求生成一个 `request_id`。
    -   `logger.configure(extra={"request_id": "N/A"})` 确保请求上下文之外的日志（如启动日志）具有默认 ID。
3.  **输出**:
    -   **控制台**: 适合开发的人类可读、彩色日志。
    -   **文件**: 存储在 `logs/app.log` 中的结构化日志。
        -   **轮转**: 每 10 MB。
        -   **保留**: 10 天。

### 日志格式
```text
YYYY-MM-DD HH:mm:ss | LEVEL    | request_id | module:function:line - Message
```

## 3. 中间件

-   **文件**: `app/middleware/request_logging.py`
-   **类**: `RequestLoggingMiddleware`

该中间件执行三个关键功能：
1.  **ID 生成**: 为每个传入的 HTTP 请求生成一个 UUID4 `request_id`。
2.  **上下文绑定**: 将此 ID 绑定到 `loguru` 上下文，确保请求生命周期内生成的所有日志都包含此 ID。
3.  **生命周期日志**:
    -   记录请求详情：`方法`, `URL`, `客户端 IP`。
    -   记录响应详情：`状态码`, `处理时间` (ms)。
    -   向响应添加 `X-Request-ID` 头。

## 4. 异常处理架构

所有自定义异常都继承自一个基类以确保一致性。

### 基类异常
-   **文件**: `app/core/exceptions.py`
-   **类**: `AppException`
-   **属性**:
    -   `message`: 人类可读的错误描述。
    -   `status_code`: HTTP 状态码 (例如 400, 500)。
    -   `code`: 内部错误代码字符串 (例如 `INTERNAL_ERROR`)。
    -   `details`: 可选的额外上下文信息字典。

### 具体异常
| 异常 | HTTP 状态 | 用途 |
| :--- | :--- | :--- |
| `ContentExtractionError` | 422 (Unprocessable Entity) | 解析 URL、PDF 或 DOCX 文件失败。 |
| `LLMProviderError` | 502 (Bad Gateway) | OpenAI 或 Gemini API 调用失败（网络、认证等）。 |
| `InvalidInputError` | 400 (Bad Request) | 验证失败（例如缺少文件、文本为空）。 |

### 全局处理器
-   **文件**: `app/core/handlers.py`
-   在 `app/main.py` 中注册。

1.  **`app_exception_handler`**: 捕获 `AppException` 并返回标准 JSON 错误响应。
2.  **`validation_exception_handler`**: 覆盖 FastAPI 默认的验证错误 (422) 以匹配我们的 JSON 模式。
3.  **`global_exception_handler`**: 捕获任何未处理的 `Exception`，通过 `logger.exception` 记录完整堆栈跟踪，并返回通用的 500 错误。

## 5. 标准化 API 响应

所有错误都返回 `app/schemas/error_response_schema.py` 中定义的一致 JSON 结构。

### 模式
```python
class BaseErrorResponse(BaseModel):
    success: bool = False
    error: str
    code: Optional[str]
    details: Optional[Dict[str, Any]]
```

### JSON 示例
```json
{
    "success": false,
    "error": "Failed to download URL",
    "code": "CONTENT_EXTRACTION_ERROR",
    "details": {
        "url": "https://example.com"
    }
}
```

## 6. 服务层集成

### 提取器 (`app/services/extractors.py`)
-   使用 `logger.debug()` 进行流程追踪。
-   捕获 `httpx` 或库错误并抛出 `ContentExtractionError`。
-   **不再返回错误字符串。**

### LLM 客户端 (`app/services/llms/*.py`)
-   使用 `logger.info()` 追踪 API 使用情况（模型、提供商）。
-   在调用前验证 API 密钥和配置。
-   捕获网络/API 错误并抛出 `LLMProviderError`。

## 7. 开发人员使用指南

1.  **日志记录**:
    始终使用 `loguru`。不要使用 `print()`。
    ```python
    from loguru import logger

    logger.info("Processing started")
    logger.error("Something went wrong", some_var=123)
    ```

2.  **抛出错误**:
    抛出 `app.core.exceptions` 中的具体异常。不要返回错误字典或字符串。
    ```python
    from app.core.exceptions import ContentExtractionError

    if not file.filename.endswith('.pdf'):
        raise ContentExtractionError("Only PDF files are supported")
    ```

3.  **捕获错误**:
    让全局处理器处理响应格式化。只有当你能从异常中恢复，或者需要将其包装在更具体的自定义异常中时，才捕获异常。
